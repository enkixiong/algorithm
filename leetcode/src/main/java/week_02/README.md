# 作业

## 散列
### 1. 两数之和
思路1: 边访问,边用hash表存储; 如果存在, 则找到结果
思路2: 排序,双指针
思路3: 两重循环, 暴力求解
 
### 242. 有效的字母异位词
    
    *  49. 字母异位词分组
    * 438. 找到字符串中所有字母异位词

统一化思路: 
1. 对字符串进行摘要信息(hashCode & 字符出现统计); 并且统计每个字符产生的次数; 而散列函数就直接用 `int[26]`, 因为都是小写字母; 如果是Unicode字符,则需要新建对应大小的数组; 或者直接用HashMap;
2. 对待匹配的字符串数组,提取特征信息, 特征信息一致,则是字母异位词; 

## 树: 遍历

### 前序遍历

144. 二叉树的前序遍历
589. N叉树的前序遍历 

### 中序遍历

94. 二叉树的中序遍历

### 后序遍历

145. 二叉树的后序遍历
590. N叉树的后序遍历

### 层次遍历

429. N叉树的层序遍历
102. 二叉树的层序遍历

#### 解题思路: 
    递归;
    两个队列,打乒乓球;
    一个队列,进入一层时,直接获取该层的大小; 
    一个循环外队列,一个循环内队列; 
    DFS: 传入参数增加一个 level 值  真的奏效吗?

173. 二叉搜索树迭代器

## 堆

### 剑指 Offer 40. 最小的k个数
####  思路1:堆

(Java用优先队列,注意,优先队列实际上构造的是小顶堆, 而这里的思路需要用大顶堆)

#### 思路2: 排序

拷贝前K个结果

#### 思路3: 快排 

如果分区的下标为 K时, 说明[0,k-1] <= [k], 则直接返回参数,找到了结果集; 这里关键的做法是: 如何在快排中选取分区点,并且完成单次快排;

    private void quickSortK(int[] nums, int k){
        int start = 0;
        int end = nums.length -1;

        int pivot = -1;
        while(pivot != k){
            pivot = quickSwap(nums, start, end);
            if(pivot < k){
                start = pivot+1;
            }else if(pivot > k){
                end = pivot-1;
            }else{
                return;
            }
        }
    }
    
    
### 239. 滑动窗口最大值
#### 思路1: 大顶堆
1. 维护K的滑动窗口; 
2. 将滑出的元素删除; (重复数据怎么办? 堆删除数据时,是将数据删除还是所有的数值全部删除?)
3. 将新进的数字进堆; 
4. 获取当前窗口内的最大值；
5. _NOTE!!_  堆中存储的还是索引; 所以, 可以直接删除值,而不会有重复数据的影响;
#### 思路2: 严格单调递减队列;
1. (如果加入数字时, 发现了 <= 该数, 则将该数删除)
2. 原理: 当前窗口内, 如果出现了更大的数字,那么, 在该数之前,比该数小的元素, 一定不会成为结果的可选项; 
3. 初始化第一个窗口,并且初始化第一个值;
4. 滑动窗口; 
5. _谨记_:  存储的下标; 对于数组，如果升维做记录,一定要记得存储的是下标，而不是值; 因为可以通过下标获取值，但是却不能通过值获取下标,尤其是在无序数组中;
