    
    问题: 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。
    
    示例：
        输入: S = "ADOBECODEBANC", T = "ABC"
        输出: "BANC"
    说明：
    
        如果 S 中不存这样的子串，则返回空字符串 ""。
        如果 S 中存在这样的子串，我们保证它是唯一的答案。

##### 解题思路

    1. 什么是子串? 包含了ABC的字符串就是一个子串
    2. 什么是最小子串? 1)满足子串; 2) 长度最小
    3. 如何检测子串?
        1) T中的字符,每一个不同的字符,就是一个标志位; 
        2）如果标志位全部为true; 则表明有一个子串产生; 
    4. 子串检测模型化: 
        问题: 
        当字符串扫描时, 如果遇见了T中的字母,则设置T的标志位；但是T的位数不知道，并且字符也是未知;
        用OX00000000表示; 因为标志位于计算机中的0,1比较对应；
        示例: S = "ADOBECODEBANC", T = "ABC"
            子串标志位为: 0X111
            A,01 --> OX00000000 & (0X001 << 2) --> 0X100
            B,04 --> 0X00000100 & (0X001 << 1) --> 0X110
            C,06 --> 0X00000110 & (0X001 << 0) --> 0X111
            此时获取一个子串: [01,06], 比较当前最小子串为[01,06] 只保留最近两个标志位: 0X011
            B,10 --> 0X00000011 & (0X001 << 1) --> 0X011
            A,11 --> 0X00000011 & (0x001 << 2) --> 0X111
            此时获取一个子串: [06,11], 比较当前最小子串为[06,11] 只保留最近两个标志位: 0X110
            C,13 --> 0X00000110 & (0X001 << 0) --> 0X111
            此时获取一个子串: [10,13], 比较当前最小子串为[10,13] 只保留最近两个标志位: 0X101
            此时待检测字符串结束; 退出循环，返回子串[10,13]
            
##### 复杂度
    1 n:输入字符串长度 m:T子串
    2 问题解答的最小复杂度: o(n+m)
    3 方案1: 如果时间复杂度为O(n*m) 则只需要一个辅助空间:标志位空间; 则空间复杂度为O(m*m)
        注: n*m 循环n, 对于每一个n[i]都需要获取 n[i] 在 m中的偏移量
        注: O(m*m): 用于保存n字符串的记录; 但是最多只保存m-1种字符串; 一个字符最多能保留m-2份；
        注: 时间复杂度: O(n*m); 
    4 方案2: 如果时间复杂度为O(n*m) 则需要两个辅助空间 标志位空间:O(m*m) 偏移量空间: O(m)
        注: 取消3.1中 寻找偏移量的时间损耗, 暂存； 但是获取的时间复杂度必须是O(1); Map结构
    
##### 实现思路:(基于上序思想；开始设计实现思路) 

    1. 如何维护偏移量? 对T进行去重,维护为Map结构, 写入&获取偏移量: O(1)
       对于该程序, 
       维护Map结构的时间复杂度为: O(m)
       访问偏移量 O(n)
    2. 构建标识:2`n-1
    3. push进入时，检测与顶端是否一致;一致则先pop;再push; 并且不做任何标志位更新操作;
    4. push进入时, 检测是否与底部元素一致；如果一致则push,再removeBottom;
    5. push进入时, 0b0001 << （1）
    6. push进入时,需要检测标志位;如果已经是一个子串,则需要比较当前子串与现有子串;取最小值暂存;
    7. 循环结束,返回最小值
    
    弊端: T只能有最长62位;
       
    
    