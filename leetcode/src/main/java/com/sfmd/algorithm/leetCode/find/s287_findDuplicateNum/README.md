##### 问题描述

    给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
    
    示例 1:
    
    输入: [1,3,4,2,2]
    输出: 2
    示例 2:
    
    输入: [3,1,3,4,2]
    输出: 3
    说明：
    
    不能更改原数组（假设数组是只读的）。
    只能使用额外的 O(1) 的空间。
    时间复杂度小于 O(n2) 。
    数组中只有一个重复的数字，但它可能不止重复出现一次。
    
##### 问题剖析

    1. 问题的本质: 抽屉原理; 将N+1个苹果放在N个格子里,必然有一个格子里至少有两个数据
    2. 本题: 将[1,N+1]的数字，放到N个格子里； 那么必然有一个格子里至少是有两个数据的; 并且题目要求，只允许一个重复数
       也就是说，没有了 [1,1,1,1,1,9,9,9,9]这种可能
    3. 转换问题: 如果找到这个重复的格子？
    
##### 问题拓展

    1. 既然是找这个重复的格子，格子可能分布在 [1,N]中，那如果用二分呢？
    2. 注意不是将数据进行排序后进行二分查询，因为数据是只读；
    3. 将格子进行二分？ 
    
##### 思路:
    1. 将[1,N]进行二分: [1,N/2] [N/2+1,N] 
    2. 在[1,N]中国重复的数据,一定在[1,N/2]和[N/2+1,N]中；
    3. 空间复杂度为1， 则表明不允许使用递归(递归的空间复杂度: O(logN))； 但是可以使用递归的思想，但是破除递归的代码实现方式；
    4. 对[1,N] 进行二分，复杂度为O(logN);
    5. 对每一个区间进行扫描，确认该区间内是否存在需要寻找的格子
    