## 作业都在子包里,今本上课后作业都完成了

全排列2的题目比较难,虽然已经做完,但是，并不能在遇见新的题型的时候,很快的就能想到: 如何控制排列的生成以及提前剪枝,
尤其是每一层只跟待交换元素的值交换一次；

## 学习笔记

### 递归

递归主要是分成四个步骤:
 
1. 终止条件
2. 处理本层问题
3. drill down
4. 恢复本层状态
5. 返回结果值

这个中间,最难的在于,drill down，转换为子问题; 

### 分治

递归是一种实现手段; 分治是一种思想，将大问题转化为小问题; 不断的进行委托代理给更小的认为,最后将结果进行汇总,得出大问题的结果;

递归有两种实现方式: 1. 利用方法栈指定递归; 2. 用Stack手动模拟方法栈,用迭代的方式实现递归

### 回溯

回溯与递归&分治最大的区别在于: 回溯一定会有恢复本层状态的处理; 而且,回溯一般都需要剪枝; 剪枝可以有效的降低复杂度; 递归&分治很容易产生重复计算, 
而重复计算最好的武器是 记忆化递归; 记忆化递归的时间性能相关的表现，有的时候,比DP还要好； 因为DP会做一些无用的计算,而记忆化递归基本有效计算; 
  
### 本周题解
同文件夹下的  **树的序列化.pdf** 文件

### 本周收获(教训)

1. 任何问题,首先第一点想到的应该是暴力解决方案; 由暴力解决方案做延伸&优化；
2. 刷题已经进入停滞期, 觉得增长有限; 现在需要做的是: 分析题型, 快速的定位问题的可以用哪些方案解决;将事情做细,而不是将事情做完; 
3. 模板式代码记忆可以减少不必要的bug
4. 当前刷题量: 263; 仅作为个人记录;
5. 已经开始在leetcode上手写, 提升自己不依赖IDE的能力
